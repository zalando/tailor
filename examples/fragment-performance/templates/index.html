<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=" rel="icon" type="image/x-icon" />
    <script>
        (function(perf){
            if (!('mark' in perf && 'measure' in perf)) {
                return;
            }
            const fragmentMap = new Map();
            const doneGroups = Object.create(null);

            const getCount = (range) => {
                return range[1] - range[0] + 1
            }
            /**
             * Group all the timing groups associated with all fragments
             * and check if the scripts are done executing
             * 
             * Meausre -> time from navigation start - all scripts from
             * fragments associated with given timing groups are done executing
             */
            const measureGroups = (groups, callback) => {
                if (groups.length < 1) {
                    return;
                }
                for (const groupName of groups) {
                    // early exit if the timing group is already done
                    if (doneGroups[groupName] !== undefined) {
                        continue;
                    }
                    let isGroupDone = true;
                    for (const id of fragmentMap.keys()) {
                        const fragment = fragmentMap.get(id);
                        const { groups } = fragment;
                        if (groups.indexOf(groupName) >= 0) {
                            if (fragment.count > 0) {
                                isGroupDone = false;
                                break;
                            }
                        }
                    }
                    if (isGroupDone) {
                        doneGroups[groupName] = true;
                        perf.measure(groupName.trim());
                    }
                }
                return;
            }

            Pipe.onStart((attributes) => {
                const { id, range, timingGroups } = attributes;
                if (!fragmentMap.has(id)) {
                    const count = getCount(range)
                    /*
                     * count - denotes the number of script tags
                     * marked - flag to check if fragment started executing
                     * measure - flag to measure sripts and fragments differently
                     * groups - timing groups associated with a fragment
                     */
                    fragmentMap.set(id, {
                        count,
                        marked: false,
                        measure: count !== 1,
                        groups: timingGroups
                    });
                }
            });
            Pipe.onBeforeInit(function(attributes) {
                const { id, timingGroups } = attributes;
                const fragment = fragmentMap.get(id);
                /**
                 * Mark only once even if fragments send multiple scripts 
                 * Helps to capture the overall time from start till all the
                 * scripts are executed from fragment
                 * 
                 * Includes network time of other scripts as well.
                 */
                if(!fragment.marked) {
                    fragment.marked = true;
                    perf.mark(id);
                }
                /**
                 * Mark for each script tag from the fragments
                 * Helps us to track how much time is spent executing 
                 * each script on the fragments
                 * 
                 * Includes only the execution time of the exported function
                 * in the script
                 */ 
                if (fragment.measure) {
                    perf.mark(id + fragment.count);
                }
            });
            Pipe.onAfterInit((attributes) => {
                const { id, timingGroups } = attributes;
                const fragment = fragmentMap.get(id);
                // Measure for each script per fragment only if
                // the script count is more than 1 per fragment
                if (fragment.measure) {
                    const markName = id + fragment.count;
                    const markEnd = markName + 'end';
                    perf.mark(markEnd);
                    perf.measure("fragment-" + markName, markName, markEnd);
                }
                fragment.count -= 1;
                /**
                 * Measures from the first script tag execution to the last one
                 * from a single fragment
                 * 
                 * fragment-{name} -> start to end
                 */
                if (fragment.count === 0) {
                    perf.mark(id + 'end');
                    perf.measure('fragment-' + id, id, id + 'end');

                    // Measure if fragments assosiated with timing groups are done
                    measureGroups(timingGroups)
                }
            });
            Pipe.onDone(() => {
                /**
                 * Measure when all the script tags from fragments 
                 * are done executing on the page
                 */
                perf.measure('all-done');
            });
        })(window.performance);
    </script>
    <script>
        define('js1', function () {
            return 'js1';
        });
        define('js2', function () {
            return 'js2';
        });
        define('js3', function () {
            return 'js3';
        });
    </script>
</head>
<body>
    <div>
        <h2>Header:</h2>
        <fragment timing-group="abovethefold,interactive" id="header" src="http://localhost:8081"></fragment>
        <h2>Product/Primary:</h2>
        <fragment timing-group="interactive" id="product" primary src="http://localhost:8082"></fragment>
        <h2>Async Footer:</h2>
        <fragment id="footer" timing-group="belowthefold" async src="http://localhost:8083"></fragment>
    </div>
</body>
</html>
